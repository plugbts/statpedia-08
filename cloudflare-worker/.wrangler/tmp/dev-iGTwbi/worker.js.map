{
  "version": 3,
  "sources": ["../bundle-QktIh6/checked-fetch.js", "../bundle-QktIh6/strip-cf-connecting-ip-header.js", "../../../src/supabaseFetch.ts", "../../../src/missingPlayers.ts", "../../../src/normalizeName.ts", "../../../src/playersLoader.ts", "../../../src/createPlayerPropsFromOdd.ts", "../../../src/worker.ts", "../../../node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts", "../../../node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts", "../bundle-QktIh6/middleware-insertion-facade.js", "../../../node_modules/wrangler/templates/middleware/common.ts", "../bundle-QktIh6/middleware-loader.entry.ts"],
  "sourceRoot": "/Users/jackie/statpedia-08/cloudflare-worker/.wrangler/tmp/dev-iGTwbi",
  "sourcesContent": ["const urls = new Set();\n\nfunction checkURL(request, init) {\n\tconst url =\n\t\trequest instanceof URL\n\t\t\t? request\n\t\t\t: new URL(\n\t\t\t\t\t(typeof request === \"string\"\n\t\t\t\t\t\t? new Request(request, init)\n\t\t\t\t\t\t: request\n\t\t\t\t\t).url\n\t\t\t\t);\n\tif (url.port && url.port !== \"443\" && url.protocol === \"https:\") {\n\t\tif (!urls.has(url.toString())) {\n\t\t\turls.add(url.toString());\n\t\t\tconsole.warn(\n\t\t\t\t`WARNING: known issue with \\`fetch()\\` requests to custom HTTPS ports in published Workers:\\n` +\n\t\t\t\t\t` - ${url.toString()} - the custom port will be ignored when the Worker is published using the \\`wrangler deploy\\` command.\\n`\n\t\t\t);\n\t\t}\n\t}\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\tconst [request, init] = argArray;\n\t\tcheckURL(request, init);\n\t\treturn Reflect.apply(target, thisArg, argArray);\n\t},\n});\n", "function stripCfConnectingIPHeader(input, init) {\n\tconst request = new Request(input, init);\n\trequest.headers.delete(\"CF-Connecting-IP\");\n\treturn request;\n}\n\nglobalThis.fetch = new Proxy(globalThis.fetch, {\n\tapply(target, thisArg, argArray) {\n\t\treturn Reflect.apply(target, thisArg, [\n\t\t\tstripCfConnectingIPHeader.apply(null, argArray),\n\t\t]);\n\t},\n});\n", "export async function supabaseFetch(env: any, table: string, { method = \"GET\", body, query = \"\" } = {}) {\n  const url = `${env.SUPABASE_URL}/rest/v1/${table}${query}`;\n\n  const res = await fetch(url, {\n    method,\n    headers: {\n      apikey: env.SUPABASE_SERVICE_KEY,\n      Authorization: `Bearer ${env.SUPABASE_SERVICE_KEY}`,\n      \"Content-Type\": \"application/json\",\n      ...(method === \"POST\" ? { Prefer: \"resolution=merge-duplicates\" } : {}),\n    },\n    body: body ? JSON.stringify(body) : undefined,\n  });\n\n  if (!res.ok) {\n    const text = await res.text();\n    console.error(`\u274C Supabase ${method} ${table} failed:`, text);\n    throw new Error(text);\n  }\n\n  return res.json();\n}\n", "// Missing Players Tracking System\n// This module handles storing unmapped players for later reconciliation\n\ninterface MissingPlayer {\n  player_name: string;\n  team: string;\n  league: string;\n  normalized_name: string;\n  generated_id: string;\n  first_seen: string;\n  last_seen: string;\n  count: number;\n  sample_odd_id?: string;\n}\n\n// Store missing players in Supabase for manual review\nexport async function storeMissingPlayer(\n  env: any, \n  playerName: string, \n  team: string, \n  league: string, \n  generatedId: string,\n  oddId?: string\n): Promise<void> {\n  try {\n    const missingPlayer: MissingPlayer = {\n      player_name: playerName,\n      team: team,\n      league: league,\n      normalized_name: normalizePlayerName(playerName),\n      generated_id: generatedId,\n      first_seen: new Date().toISOString(),\n      last_seen: new Date().toISOString(),\n      count: 1,\n      sample_odd_id: oddId\n    };\n\n    // Try to upsert into missing_players table\n    await fetch(`${env.SUPABASE_URL}/rest/v1/missing_players`, {\n      method: 'POST',\n      headers: {\n        'apikey': env.SUPABASE_SERVICE_KEY,\n        'Authorization': `Bearer ${env.SUPABASE_SERVICE_KEY}`,\n        'Content-Type': 'application/json',\n        'Prefer': 'resolution=merge-duplicates'\n      },\n      body: JSON.stringify(missingPlayer)\n    });\n\n    console.log(`\uD83D\uDCDD Stored missing player: ${playerName} (${team})`);\n  } catch (error) {\n    console.error(`\u274C Failed to store missing player ${playerName}:`, error);\n  }\n}\n\n// Normalize player name for consistent tracking\nfunction normalizePlayerName(name: string): string {\n  return name.toLowerCase()\n    .replace(/[^\\w\\s]/g, '') // Remove punctuation\n    .replace(/\\s+/g, ' ') // Normalize spaces\n    .replace(/\\s(jr|sr|iii|iv|v)$/i, '') // Remove suffixes\n    .trim();\n}\n\n// Get missing players for manual review\nexport async function getMissingPlayers(env: any, limit: number = 100): Promise<MissingPlayer[]> {\n  try {\n    const response = await fetch(`${env.SUPABASE_URL}/rest/v1/missing_players?order=count.desc&limit=${limit}`, {\n      headers: {\n        'apikey': env.SUPABASE_SERVICE_KEY,\n        'Authorization': `Bearer ${env.SUPABASE_SERVICE_KEY}`\n      }\n    });\n\n    if (!response.ok) {\n      throw new Error(`Failed to fetch missing players: ${response.statusText}`);\n    }\n\n    return await response.json();\n  } catch (error) {\n    console.error('\u274C Failed to fetch missing players:', error);\n    return [];\n  }\n}\n", "// Name normalization utility for consistent player matching\n// This function normalizes player names for mapping lookup\n\nexport function normalizeName(name: string): string {\n  return name.toLowerCase()\n    .replace(/[^\\w\\s]/g, '') // Remove punctuation\n    .replace(/\\s+/g, ' ') // Normalize spaces\n    .replace(/\\s(jr|sr|iii|iv|v)$/i, '') // Remove suffixes\n    .trim();\n}\n\n// Alternative normalization for more aggressive matching\nexport function aggressiveNormalizeName(name: string): string {\n  return name.toLowerCase()\n    .replace(/[^\\w]/g, '') // Remove all non-word characters\n    .replace(/\\s(jr|sr|iii|iv|v)$/i, '') // Remove suffixes\n    .trim();\n}\n\n// Generate possible name variations for fuzzy matching\nexport function generateNameVariations(name: string): string[] {\n  const normalized = normalizeName(name);\n  const variations = [normalized];\n  \n  // Add aggressive normalization\n  variations.push(aggressiveNormalizeName(name));\n  \n  // Add variations without common prefixes\n  const withoutPrefix = normalized.replace(/^(jr|sr|iii|iv|v)\\s+/i, '');\n  if (withoutPrefix !== normalized) {\n    variations.push(withoutPrefix);\n  }\n  \n  // Add first name only\n  const firstName = normalized.split(' ')[0];\n  if (firstName && firstName.length > 2) {\n    variations.push(firstName);\n  }\n  \n  // Add last name only\n  const lastName = normalized.split(' ').pop();\n  if (lastName && lastName.length > 2 && lastName !== firstName) {\n    variations.push(lastName);\n  }\n  \n  return [...new Set(variations)]; // Remove duplicates\n}\n", "// Players Loader - Auto-populate PLAYER_ID_MAP from Supabase\nimport { supabaseFetch } from \"./supabaseFetch\";\nimport { normalizeName, generateNameVariations } from \"./normalizeName\";\n\ninterface Player {\n  player_id: string;\n  full_name: string;\n  team: string;\n  league: string;\n  position?: string;\n}\n\nexport async function loadPlayerIdMap(env: any): Promise<Record<string, string>> {\n  try {\n    console.log('\uD83D\uDD04 Loading players from Supabase...');\n    \n    // Pull all players (paginate if large)\n    const players = await supabaseFetch(env, \"players\", {\n      query: \"?select=player_id,full_name,team,league,position&limit=10000\"\n    });\n\n    if (!players || !Array.isArray(players)) {\n      console.error('\u274C Failed to load players from Supabase');\n      return {};\n    }\n\n    const map: Record<string, string> = {};\n    let loadedCount = 0;\n    let skippedCount = 0;\n\n    for (const player of players as Player[]) {\n      if (!player.full_name || !player.player_id) {\n        skippedCount++;\n        continue;\n      }\n\n      // Create primary mapping with normalized name\n      const normalizedKey = normalizeName(player.full_name);\n      map[normalizedKey] = player.player_id;\n      loadedCount++;\n\n      // Add variations for better matching\n      const variations = generateNameVariations(player.full_name);\n      for (const variation of variations) {\n        if (variation !== normalizedKey && !map[variation]) {\n          map[variation] = player.player_id;\n        }\n      }\n    }\n\n    console.log(`\u2705 Loaded ${loadedCount} players into PLAYER_ID_MAP (${Object.keys(map).length} total mappings)`);\n    console.log(`\u26A0\uFE0F Skipped ${skippedCount} players due to missing data`);\n    \n    return map;\n  } catch (error) {\n    console.error('\u274C Error loading player ID map:', error);\n    return {};\n  }\n}\n\n// Cache the player map to avoid repeated API calls\nlet playerMapCache: Record<string, string> | null = null;\nlet cacheTimestamp: number = 0;\nconst CACHE_TTL = 30 * 60 * 1000; // 30 minutes\n\nexport async function getCachedPlayerIdMap(env: any): Promise<Record<string, string>> {\n  const now = Date.now();\n  \n  // Return cached map if still valid\n  if (playerMapCache && (now - cacheTimestamp) < CACHE_TTL) {\n    return playerMapCache;\n  }\n  \n  // Load fresh map and update cache\n  playerMapCache = await loadPlayerIdMap(env);\n  cacheTimestamp = now;\n  \n  return playerMapCache;\n}\n\n// Load players by league for targeted updates\nexport async function loadPlayerIdMapByLeague(env: any, league: string): Promise<Record<string, string>> {\n  try {\n    console.log(`\uD83D\uDD04 Loading ${league} players from Supabase...`);\n    \n    const players = await supabaseFetch(env, \"players\", {\n      query: `?select=player_id,full_name,team,league,position&league=eq.${league}&limit=5000`\n    });\n\n    if (!players || !Array.isArray(players)) {\n      console.error(`\u274C Failed to load ${league} players from Supabase`);\n      return {};\n    }\n\n    const map: Record<string, string> = {};\n    let loadedCount = 0;\n\n    for (const player of players as Player[]) {\n      if (!player.full_name || !player.player_id) continue;\n\n      const normalizedKey = normalizeName(player.full_name);\n      map[normalizedKey] = player.player_id;\n      loadedCount++;\n\n      // Add variations\n      const variations = generateNameVariations(player.full_name);\n      for (const variation of variations) {\n        if (variation !== normalizedKey && !map[variation]) {\n          map[variation] = player.player_id;\n        }\n      }\n    }\n\n    console.log(`\u2705 Loaded ${loadedCount} ${league} players (${Object.keys(map).length} total mappings)`);\n    return map;\n  } catch (error) {\n    console.error(`\u274C Error loading ${league} player ID map:`, error);\n    return {};\n  }\n}\n\n// Update missing players table with successful mappings\nexport async function updateMissingPlayersSuccess(env: any, playerName: string, canonicalId: string): Promise<void> {\n  try {\n    const normalizedName = normalizeName(playerName);\n    \n    // Remove from missing players table since we now have a mapping\n    await fetch(`${env.SUPABASE_URL}/rest/v1/missing_players?normalized_name=eq.${normalizedName}`, {\n      method: 'DELETE',\n      headers: {\n        'apikey': env.SUPABASE_SERVICE_KEY,\n        'Authorization': `Bearer ${env.SUPABASE_SERVICE_KEY}`,\n        'Content-Type': 'application/json'\n      }\n    });\n    \n    console.log(`\u2705 Removed ${playerName} from missing players (mapped to ${canonicalId})`);\n  } catch (error) {\n    console.error(`\u274C Failed to update missing players for ${playerName}:`, error);\n  }\n}\n", "import { toYmd } from \"./helpers\";\nimport { storeMissingPlayer } from \"./missingPlayers\";\nimport { getCachedPlayerIdMap, updateMissingPlayersSuccess } from \"./playersLoader\";\nimport { normalizeName } from \"./normalizeName\";\n\n// Market mapping for prop types\nconst MARKET_MAP: Record<string, string> = {\n  // NFL Passing\n  'passing yards': 'Passing Yards',\n  'pass yards': 'Passing Yards',\n  'passing yds': 'Passing Yards',\n  'pass yds': 'Passing Yards',\n  'passing yards passing': 'Passing Yards',\n  'passing touchdowns': 'Passing Touchdowns',\n  'pass tds': 'Passing Touchdowns',\n  'passing td': 'Passing Touchdowns',\n  'pass td': 'Passing Touchdowns',\n  'passing attempts': 'Passing Attempts',\n  'pass attempts': 'Passing Attempts',\n  'pass att': 'Passing Attempts',\n  'passing completions': 'Passing Completions',\n  'pass completions': 'Passing Completions',\n  'pass comp': 'Passing Completions',\n  'passing interceptions': 'Passing Interceptions',\n  'pass interceptions': 'Passing Interceptions',\n  'pass int': 'Passing Interceptions',\n  \n  // NFL Rushing\n  'rushing yards': 'Rushing Yards',\n  'rush yards': 'Rushing Yards',\n  'rushing yds': 'Rushing Yards',\n  'rush yds': 'Rushing Yards',\n  'rushing touchdowns': 'Rushing Touchdowns',\n  'rush tds': 'Rushing Touchdowns',\n  'rushing td': 'Rushing Touchdowns',\n  'rush td': 'Rushing Touchdowns',\n  'rushing attempts': 'Rushing Attempts',\n  'rush attempts': 'Rushing Attempts',\n  'rush att': 'Rushing Attempts',\n  \n  // NFL Receiving\n  'receiving yards': 'Receiving Yards',\n  'rec yards': 'Receiving Yards',\n  'receiving yds': 'Receiving Yards',\n  'rec yds': 'Receiving Yards',\n  'receiving touchdowns': 'Receiving Touchdowns',\n  'rec tds': 'Receiving Touchdowns',\n  'receiving td': 'Receiving Touchdowns',\n  'rec td': 'Receiving Touchdowns',\n  'receptions': 'Receptions',\n  'rec': 'Receptions',\n  \n  // NFL Defense\n  'defense sacks': 'Defense Sacks',\n  'defense interceptions': 'Defense Interceptions',\n  'defense combined tackles': 'Defense Combined Tackles',\n  'defense total tackles': 'Defense Combined Tackles',\n  \n  // NFL Kicking\n  'field goals made': 'Field Goals Made',\n  'kicking total points': 'Kicking Total Points',\n  'extra points kicks made': 'Extra Points Made',\n  \n  // NBA\n  'points': 'Points',\n  'rebounds': 'Rebounds',\n  'assists': 'Assists',\n  'steals': 'Steals',\n  'blocks': 'Blocks',\n  'threes made': 'Three Pointers Made',\n  '3-pointers made': 'Three Pointers Made',\n  \n  // MLB\n  'hits': 'Hits',\n  'runs': 'Runs',\n  'rbis': 'RBIs',\n  'strikeouts': 'Strikeouts',\n  'walks': 'Walks',\n  'home runs': 'Home Runs',\n  \n  // NHL\n  'goals': 'Goals',\n  'shots': 'Shots',\n  'saves': 'Saves',\n};\n\n// Get canonical player ID with dynamic loading from Supabase\nasync function getPlayerID(playerName: string, team: string, league: string, env?: any): Promise<string | null> {\n  if (!env) {\n    // Fallback if env not available\n    const canonicalName = playerName.toUpperCase()\n      .replace(/[^\\w\\s]/g, '')\n      .replace(/\\s+/g, '_')\n      .replace(/\\s(jr|sr|iii|iv|v)$/i, '')\n      .trim();\n    return `${canonicalName}-UNK-${team}`;\n  }\n\n  try {\n    // Load dynamic player map from Supabase\n    const playerMap = await getCachedPlayerIdMap(env);\n    const normalizedName = normalizeName(playerName);\n    \n    // Try exact match first\n    if (playerMap[normalizedName]) {\n      const canonicalId = playerMap[normalizedName];\n      console.log(`\u2705 Found player mapping: ${playerName} \u2192 ${canonicalId}`);\n      \n      // Update missing players table to remove this player\n      await updateMissingPlayersSuccess(env, playerName, canonicalId);\n      \n      return canonicalId;\n    }\n    \n    // Try partial matches for common name variations\n    for (const [key, value] of Object.entries(playerMap)) {\n      if (key.includes(normalizedName) || normalizedName.includes(key)) {\n        const canonicalId = value;\n        console.log(`\u2705 Found fuzzy player mapping: ${playerName} \u2192 ${canonicalId}`);\n        \n        // Update missing players table to remove this player\n        await updateMissingPlayersSuccess(env, playerName, canonicalId);\n        \n        return canonicalId;\n      }\n    }\n    \n    // Fallback: generate canonical ID\n    const canonicalName = playerName.toUpperCase()\n      .replace(/[^\\w\\s]/g, '')\n      .replace(/\\s+/g, '_')\n      .replace(/\\s(jr|sr|iii|iv|v)$/i, '')\n      .trim();\n    \n    return `${canonicalName}-UNK-${team}`;\n    \n  } catch (error) {\n    console.error(`\u274C Error loading player map for ${playerName}:`, error);\n    \n    // Fallback on error\n    const canonicalName = playerName.toUpperCase()\n      .replace(/[^\\w\\s]/g, '')\n      .replace(/\\s+/g, '_')\n      .replace(/\\s(jr|sr|iii|iv|v)$/i, '')\n      .trim();\n    \n    return `${canonicalName}-UNK-${team}`;\n  }\n}\n\nexport async function createPlayerPropsFromOdd(odd: any, oddId: string, event: any, league: string, season: string, week?: string, env?: any): Promise<any[]> {\n  const props: any[] = [];\n  \n  // Extract player information\n  const playerName = odd.player?.name;\n  const team = odd.player?.team;\n  \n  if (!playerName || !team) {\n    console.log(`Skipping odd ${oddId}: missing player name or team`);\n    return props;\n  }\n\n  // Get canonical player ID with dynamic loading\n  const playerID = await getPlayerID(playerName, team, league, env);\n  \n  if (!playerID) {\n    console.error(\"Failed to generate player_id mapping\", { \n      playerName, \n      team, \n      league, \n      normalizedName: normalizeName(playerName)\n    });\n    return props;\n  }\n  \n  // Store missing player mappings for manual review\n  if (playerID.includes('-UNK-') && env) {\n    console.error(\"Missing player_id mapping\", { \n      playerName, \n      team, \n      league, \n      generatedId: playerID,\n      normalizedName: normalizeName(playerName)\n    });\n    \n    // Store in missing_players table for later reconciliation\n    await storeMissingPlayer(env, playerName, team, league, playerID, oddId);\n  }\n  \n  // Extract game date - use event date, not ingestion date\n  const gameDate = event.date ? event.date.split('T')[0] : new Date().toISOString().split('T')[0];\n  \n  // Extract prop information\n  const rawPropType = odd.prop?.name;\n  const line = odd.line;\n  const overOdds = odd.overOdds;\n  const underOdds = odd.underOdds;\n  const sportsbook = mapBookmakerIdToName(odd.bookmaker?.id || 'unknown') || 'Consensus';\n  \n  if (!rawPropType || line == null) {\n    console.log(`Skipping odd ${oddId}: missing prop type or line`);\n    return props;\n  }\n\n  // Normalize prop type using market mapping\n  const normalizedPropType = MARKET_MAP[rawPropType.toLowerCase()] || rawPropType;\n  \n  // Log unmapped markets for manual review\n  if (!MARKET_MAP[rawPropType.toLowerCase()]) {\n    console.warn(\"Unmapped market:\", {\n      rawMarket: rawPropType,\n      oddId: oddId,\n      player: playerName,\n      league: league\n    });\n  }\n\n  // Extract additional event information\n  const gameId = event.eventID || `${team}-${event.teams?.find((t: any) => t !== team)}-${gameDate}`;\n  const homeTeam = event.homeTeam || event.teams?.[0];\n  const awayTeam = event.awayTeam || event.teams?.[1];\n  const gameTime = event.date ? new Date(event.date) : new Date();\n\n  // Create the prop record matching proplines schema\n  const prop = {\n    player_id: playerID,\n    player_name: playerName,\n    team: team,\n    opponent: event.teams?.find((t: any) => t !== team) || null,\n    prop_type: normalizedPropType,\n    line: parseFloat(line),\n    over_odds: overOdds ? parseInt(overOdds) : null,\n    under_odds: underOdds ? parseInt(underOdds) : null,\n    sportsbook: sportsbook,\n    sportsbook_key: odd.bookmaker?.id || 'consensus',\n    game_id: gameId,\n    game_time: gameTime.toISOString(),\n    home_team: homeTeam || '',\n    away_team: awayTeam || '',\n    league: league.toLowerCase(),\n    season: season,\n    week: week || null,\n    conflict_key: `${playerID}-${normalizedPropType}-${line}-${sportsbook}-${gameDate}`,\n    last_updated: new Date().toISOString(),\n    is_available: true\n  };\n\n  props.push(prop);\n  return props;\n}\n\nfunction mapBookmakerIdToName(bookmakerId: string): string {\n  const bookmakerMap: Record<string, string> = {\n    'draftkings': 'DraftKings',\n    'fanduel': 'FanDuel',\n    'betmgm': 'BetMGM',\n    'caesars': 'Caesars',\n    'pointsbet': 'PointsBet',\n    'betrivers': 'BetRivers',\n    'unibet': 'Unibet',\n    'sugarhouse': 'SugarHouse',\n    'foxbet': 'FOX Bet',\n    'bet365': 'Bet365',\n    'williamhill': 'William Hill',\n    'pinnacle': 'Pinnacle',\n    'betfair': 'Betfair',\n    'bovada': 'Bovada',\n    'mybookie': 'MyBookie',\n    'consensus': 'Consensus',\n    'unknown': 'Consensus'\n  };\n  \n  return bookmakerMap[bookmakerId.toLowerCase()] || 'Consensus';\n}\n", "import { supabaseFetch } from \"./supabaseFetch\";\nimport { chunk } from \"./helpers\";\nimport { createPlayerPropsFromOdd } from \"./createPlayerPropsFromOdd\";\n\n// Add missing functions from simple-ingestion.ts\nasync function fetchEvents(env: any, sportID: string, season: string, week?: string): Promise<any[]> {\n  let allEvents: any[] = [];\n  let nextCursor: string | null = null;\n  let pageCount = 0;\n  const maxPages = 2; // Conservative for testing\n\n  // Primary query attempt\n  try {\n    allEvents = await fetchEventsWithParams(env, sportID, season, week);\n    console.log(`Primary query successful: ${allEvents.length} events`);\n    return allEvents;\n  } catch (error) {\n    console.error('Primary query failed:', error);\n  }\n\n  // Fallback 1: Try season 2024 if current season returns 0\n  if (season === '2025' && allEvents.length === 0) {\n    console.log('Trying fallback: season 2024');\n    try {\n      const fallbackEvents = await fetchEventsWithParams(env, sportID, '2024', week);\n      if (fallbackEvents.length > 0) {\n        console.log(`Fallback successful: found ${fallbackEvents.length} events for season 2024`);\n        return fallbackEvents;\n      }\n    } catch (error) {\n      console.error('Season 2024 fallback failed:', error);\n    }\n  }\n\n  // Fallback 2: Try without week filter if week was specified\n  if (week && allEvents.length === 0) {\n    console.log('Trying fallback: without week filter');\n    try {\n      const fallbackEvents = await fetchEventsWithParams(env, sportID, season);\n      if (fallbackEvents.length > 0) {\n        console.log(`Fallback successful: found ${fallbackEvents.length} events without week filter`);\n        return fallbackEvents;\n      }\n    } catch (error) {\n      console.error('No week filter fallback failed:', error);\n    }\n  }\n\n  // Fallback 3: Try with relaxed filters (remove oddsAvailable and markets filters)\n  if (allEvents.length === 0) {\n    console.log('Trying fallback: relaxed filters');\n    try {\n      const fallbackEvents = await fetchEventsWithParams(env, sportID, season, week, true);\n      if (fallbackEvents.length > 0) {\n        console.log(`Fallback successful: found ${fallbackEvents.length} events with relaxed filters`);\n        return fallbackEvents;\n      }\n    } catch (error) {\n      console.error('Relaxed filters fallback failed:', error);\n    }\n  }\n\n  console.log(`All fallback attempts exhausted. Total events: ${allEvents.length}`);\n  return allEvents;\n}\n\nasync function fetchEventsWithParams(env: any, sportID: string, season: string, week?: string, relaxed = false): Promise<any[]> {\n  let allEvents: any[] = [];\n  let nextCursor: string | null = null;\n  let pageCount = 0;\n  const maxPages = 2;\n\n  do {\n    try {\n      // Build endpoint with optional relaxed filters\n      let endpoint = `/v2/events?sportID=${sportID}&season=${season}&limit=10`;\n      \n      if (!relaxed) {\n        endpoint += `&oddsAvailable=true&markets=playerProps`;\n      }\n      \n      if (week) {\n        endpoint += `&week=${week}`;\n      }\n      \n      if (nextCursor) {\n        endpoint += `&cursor=${nextCursor}`;\n      }\n\n      console.log(`Fetching events from: ${endpoint}${relaxed ? ' (relaxed filters)' : ''}`);\n      \n      const response = await fetch(`https://api.sportsgameodds.com${endpoint}`, {\n        headers: {\n          'Accept': 'application/json',\n          'User-Agent': 'Statpedia/1.0',\n          'x-api-key': env.SGO_API_KEY\n        }\n      });\n\n      if (!response.ok) {\n        throw new Error(`API request failed: ${response.status} ${response.statusText}`);\n      }\n\n      const data = await response.json();\n      console.log(`API response: ${data.events?.length || 0} events, nextCursor: ${data.nextCursor || 'null'}`);\n      \n      if (data.events && data.events.length > 0) {\n        allEvents.push(...data.events);\n      }\n      \n      nextCursor = data.nextCursor;\n      pageCount++;\n      \n      if (pageCount >= maxPages) {\n        console.log(`Reached max pages (${maxPages}), stopping`);\n        break;\n      }\n      \n    } catch (error) {\n      console.error('Error fetching events:', error);\n      break;\n    }\n  } while (nextCursor);\n\n  console.log(`Total events fetched: ${allEvents.length}`);\n  return allEvents;\n}\n\nasync function extractPlayerPropsFromEvent(event: any, league: string, season: string, week?: string, env?: any): Promise<any[]> {\n  const props: any[] = [];\n  \n  let playerPropOdds = 0;\n  let totalOdds = 0;\n\n  if (!event.odds) {\n    console.log(`Event ${event.eventID} has no odds`);\n    return props;\n  }\n\n  const odds = Object.entries(event.odds);\n  console.log(`Fetched odds: ${odds.length}`);\n\n  for (const [oddId, odd] of odds) {\n    totalOdds++;\n    \n    if (isPlayerProp(odd)) {\n      playerPropOdds++;\n      console.log(`Found player prop odd: ${oddId}`);\n      \n      try {\n        const playerProps = await createPlayerPropsFromOdd(odd, oddId, event, league, season, week, env);\n        if (playerProps && playerProps.length > 0) {\n          props.push(...playerProps);\n        }\n      } catch (error) {\n        console.error(`Error creating player props for odd ${oddId}:`, error);\n      }\n    }\n  }\n\n  console.log(`After market filter: ${playerPropOdds} player prop odds found`);\n  console.log(`After mapping: ${props.length} props created`);\n  console.log(`Event ${event.eventID}: ${playerPropOdds} player prop odds found, ${props.length} props created out of ${totalOdds} total odds`);\n  return props;\n}\n\nfunction isPlayerProp(odd: any): boolean {\n  if (!odd || !odd.prop || !odd.player) {\n    return false;\n  }\n\n  // Check if it's a player prop by looking at the prop type\n  const propType = odd.prop.name?.toLowerCase() || '';\n  const playerPropTypes = [\n    'passing yards', 'rushing yards', 'receiving yards',\n    'passing touchdowns', 'rushing touchdowns', 'receiving touchdowns',\n    'passing completions', 'passing attempts',\n    'receptions', 'interceptions',\n    'points', 'rebounds', 'assists', 'steals', 'blocks',\n    'hits', 'runs', 'rbis', 'strikeouts', 'walks',\n    'goals', 'assists', 'shots', 'saves',\n    // Additional variations\n    'pass yards', 'rush yards', 'rec yards',\n    'pass tds', 'rush tds', 'rec tds',\n    'completions', 'attempts',\n    'anytime td', 'player rush tds'\n  ];\n\n  const isPlayerProp = playerPropTypes.some(type => propType.includes(type));\n  \n  if (!isPlayerProp) {\n    console.warn(\"Unmapped market:\", { propType, oddId: odd.id, player: odd.player?.name });\n  }\n\n  return isPlayerProp;\n}\n\n// Batching utility function\nfunction chunk<T>(arr: T[], size: number): T[][] {\n  const out = [];\n  for (let i = 0; i < arr.length; i += size) {\n    out.push(arr.slice(i, i + size));\n  }\n  return out;\n}\n\nasync function upsertProps(env: any, props: any[]): Promise<{ inserted: number; updated: number; errors: number }> {\n  let inserted = 0;\n  let updated = 0;\n  let errors = 0;\n\n  try {\n    if (props.length === 0) {\n      console.log(\"No props to upsert\");\n      return { inserted: 0, updated: 0, errors: 0 };\n    }\n\n    // Validate props before upserting\n    const validatedProps = props.filter(prop => {\n      if (!prop.player_id || !prop.date || !prop.prop_type) {\n        console.error(\"Invalid prop missing critical fields:\", prop);\n        return false;\n      }\n      return true;\n    });\n\n    if (validatedProps.length === 0) {\n      console.log(\"No valid props to upsert\");\n      return { inserted: 0, updated: 0, errors: props.length };\n    }\n\n    // Chunk to avoid payload limits (\u2264 500 rows per request)\n    const batches = chunk(validatedProps, 500);\n    console.log(`Processing ${batches.length} batches of props`);\n    console.log(`After batching: ${batches.reduce((n, b) => n + b.length, 0)} total props in batches`);\n\n    for (const batch of batches) {\n      try {\n        // Try to upsert with retry logic\n        await supabaseFetch(env, \"proplines\", {\n          method: \"POST\",\n          body: batch,\n        });\n        inserted += batch.length;\n        console.log(`\u2705 Successfully upserted batch of ${batch.length} proplines records`);\n      } catch (error) {\n        console.error(`\u274C Error upserting batch, retrying:`, error);\n        \n        // Retry once on failure\n        try {\n          await supabaseFetch(env, \"proplines\", {\n            method: \"POST\",\n            body: batch,\n          });\n          inserted += batch.length;\n          console.log(`\u2705 Successfully upserted batch of ${batch.length} proplines records on retry`);\n        } catch (retryError) {\n          console.error(`\u274C Failed to upsert batch after retry:`, retryError);\n          errors += batch.length;\n        }\n      }\n    }\n\n    // Summary logs for observability\n    console.log(`\uD83D\uDCCA Inserted ${inserted} props, dropped ${props.length - inserted - errors}, errors: ${errors}`);\n\n  } catch (error) {\n    console.error('\u274C Exception during proplines upsert:', {\n      error: error,\n      errorMessage: error.message,\n      propsCount: props.length\n    });\n    errors += props.length;\n  }\n\n  return { inserted, updated, errors };\n}\n\n// Scheduled handler for cron jobs\nasync function scheduledHandler(env: any, event: ScheduledEvent) {\n  console.log(`\uD83D\uDD50 Scheduled ingestion triggered at ${new Date().toISOString()}`);\n  \n  try {\n    // Run ingestion for all major leagues\n    const leagues = ['NFL', 'NBA', 'MLB', 'NHL'];\n    const season = new Date().getFullYear().toString();\n    \n    let totalInserted = 0;\n    let totalErrors = 0;\n    \n    for (const league of leagues) {\n      console.log(`\uD83C\uDFC8 Starting scheduled ingestion for ${league}`);\n      \n      try {\n        // Map league to sportID\n        const sportID = league === 'NFL' || league === 'NCAAF' ? 'FOOTBALL' :\n                       league === 'NBA' || league === 'NCAAB' ? 'BASKETBALL' :\n                       league === 'MLB' ? 'BASEBALL' :\n                       league === 'NHL' ? 'HOCKEY' : 'FOOTBALL';\n        \n        // Fetch events\n        const events = await fetchEvents(env, sportID, season);\n        console.log(`Fetched ${events.length} events for ${league}`);\n        \n        if (events.length === 0) {\n          console.log(`No events found for ${league}, skipping`);\n          continue;\n        }\n        \n        let leagueInserted = 0;\n        let leagueErrors = 0;\n        \n        // Process events\n        for (const event of events) {\n          try {\n            const props = await extractPlayerPropsFromEvent(event, league, season, undefined, env);\n            if (props.length > 0) {\n              const upsertResult = await upsertProps(env, props);\n              leagueInserted += upsertResult.inserted;\n              leagueErrors += upsertResult.errors;\n            }\n          } catch (error) {\n            console.error(`Error processing event ${event.eventID}:`, error);\n            leagueErrors++;\n          }\n        }\n        \n        totalInserted += leagueInserted;\n        totalErrors += leagueErrors;\n        \n        console.log(`\u2705 ${league}: ${leagueInserted} inserted, ${leagueErrors} errors`);\n        \n      } catch (error) {\n        console.error(`\u274C Error processing ${league}:`, error);\n        totalErrors++;\n      }\n    }\n    \n    console.log(`\uD83C\uDFAF Scheduled ingestion complete: ${totalInserted} total inserted, ${totalErrors} total errors`);\n    \n  } catch (error) {\n    console.error('\u274C Scheduled ingestion failed:', error);\n  }\n}\n\nexport default {\n  async fetch(req: Request, env: any) {\n    try {\n      const url = new URL(req.url);\n      \n      // Handle CORS preflight\n      if (req.method === 'OPTIONS') {\n        return new Response(null, {\n          status: 200,\n          headers: {\n            'Access-Control-Allow-Origin': '*',\n            'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',\n            'Access-Control-Allow-Headers': 'Content-Type',\n          },\n        });\n      }\n\n      // Handle ingestion endpoint\n      if (url.pathname === '/ingest') {\n        const body = await req.json();\n        const { league = 'NFL', season = '2025', week } = body;\n        \n        console.log(`Starting prop ingestion for league: ${league}, season: ${season}, week: ${week || 'all'}`);\n        \n        const startTime = Date.now();\n        \n        try {\n          // Map league to sportID exactly as before\n          const sportID = league === 'NFL' || league === 'NCAAF' ? 'FOOTBALL' :\n                         league === 'NBA' || league === 'NCAAB' ? 'BASKETBALL' :\n                         league === 'MLB' ? 'BASEBALL' :\n                         league === 'NHL' ? 'HOCKEY' : 'FOOTBALL';\n          \n          console.log(`Processing ${league} (${sportID})`);\n          \n          // Fetch events using EXACT v2 API parameters\n          const events = await fetchEvents(env, sportID, season, week);\n          console.log(`Fetched ${events.length} events for ${league}`);\n          \n          // Fallback logic is now handled in fetchEvents function\n          \n          let totalProps = 0;\n          let totalInserted = 0;\n          let totalUpdated = 0;\n          let totalErrors = 0;\n          \n          if (events.length > 0) {\n            console.log(`Processing ${events.length} events`);\n            \n            for (const event of events) {\n              try {\n                console.log(`Processing event ${event.eventID} with ${Object.keys(event.odds || {}).length} odds`);\n                const props = await extractPlayerPropsFromEvent(event, league, season, week, env);\n                console.log(`Extracted ${props.length} props from event ${event.eventID}`);\n                \n                if (props.length > 0) {\n                  console.log(`Found ${props.length} props in event ${event.eventID}`);\n                  const upsertResult = await upsertProps(env, props);\n                  totalInserted += upsertResult.inserted;\n                  totalUpdated += upsertResult.updated;\n                  totalErrors += upsertResult.errors;\n                  totalProps += props.length;\n                }\n              } catch (error) {\n                console.error(`Error processing event ${event.eventID}:`, error);\n                totalErrors++;\n              }\n            }\n          }\n          \n          const duration = Date.now() - startTime;\n          \n          return new Response(JSON.stringify({\n            success: true,\n            message: \"Prop ingestion completed successfully\",\n            duration: `${duration}ms`,\n            totalProps,\n            inserted: totalInserted,\n            updated: totalUpdated,\n            errors: totalErrors,\n            leagues: [league]\n          }), {\n            status: 200,\n            headers: {\n              'Content-Type': 'application/json',\n              'Access-Control-Allow-Origin': '*',\n            },\n          });\n          \n        } catch (error) {\n          console.error('Ingestion failed:', error);\n          return new Response(JSON.stringify({\n            success: false,\n            message: \"Prop ingestion failed\",\n            error: error.message\n          }), {\n            status: 500,\n            headers: {\n              'Content-Type': 'application/json',\n              'Access-Control-Allow-Origin': '*',\n            },\n          });\n        }\n      }\n\n      // Default response\n      return new Response('Statpedia Player Props Worker', { status: 200 });\n    } catch (err) {\n      console.error(\"Worker error:\", err);\n      return new Response(\"Internal error\", { status: 500 });\n    }\n  },\n\n  // Scheduled handler for cron jobs\n  async scheduled(event: ScheduledEvent, env: any, ctx: ExecutionContext) {\n    ctx.waitUntil(scheduledHandler(env, event));\n  },\n};\n", "import type { Middleware } from \"./common\";\n\nconst drainBody: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} finally {\n\t\ttry {\n\t\t\tif (request.body !== null && !request.bodyUsed) {\n\t\t\t\tconst reader = request.body.getReader();\n\t\t\t\twhile (!(await reader.read()).done) {}\n\t\t\t}\n\t\t} catch (e) {\n\t\t\tconsole.error(\"Failed to drain the unused request body.\", e);\n\t\t}\n\t}\n};\n\nexport default drainBody;\n", "import type { Middleware } from \"./common\";\n\ninterface JsonError {\n\tmessage?: string;\n\tname?: string;\n\tstack?: string;\n\tcause?: JsonError;\n}\n\nfunction reduceError(e: any): JsonError {\n\treturn {\n\t\tname: e?.name,\n\t\tmessage: e?.message ?? String(e),\n\t\tstack: e?.stack,\n\t\tcause: e?.cause === undefined ? undefined : reduceError(e.cause),\n\t};\n}\n\n// See comment in `bundle.ts` for details on why this is needed\nconst jsonError: Middleware = async (request, env, _ctx, middlewareCtx) => {\n\ttry {\n\t\treturn await middlewareCtx.next(request, env);\n\t} catch (e: any) {\n\t\tconst error = reduceError(e);\n\t\treturn Response.json(error, {\n\t\t\tstatus: 500,\n\t\t\theaders: { \"MF-Experimental-Error-Stack\": \"true\" },\n\t\t});\n\t}\n};\n\nexport default jsonError;\n", "\t\t\t\timport worker, * as OTHER_EXPORTS from \"/Users/jackie/statpedia-08/cloudflare-worker/src/worker.ts\";\n\t\t\t\timport * as __MIDDLEWARE_0__ from \"/Users/jackie/statpedia-08/cloudflare-worker/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts\";\nimport * as __MIDDLEWARE_1__ from \"/Users/jackie/statpedia-08/cloudflare-worker/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts\";\n\n\t\t\t\texport * from \"/Users/jackie/statpedia-08/cloudflare-worker/src/worker.ts\";\n\n\t\t\t\texport const __INTERNAL_WRANGLER_MIDDLEWARE__ = [\n\t\t\t\t\t\n\t\t\t\t\t__MIDDLEWARE_0__.default,__MIDDLEWARE_1__.default\n\t\t\t\t]\n\t\t\t\texport default worker;", "export type Awaitable<T> = T | Promise<T>;\n// TODO: allow dispatching more events?\nexport type Dispatcher = (\n\ttype: \"scheduled\",\n\tinit: { cron?: string }\n) => Awaitable<void>;\n\nexport type IncomingRequest = Request<\n\tunknown,\n\tIncomingRequestCfProperties<unknown>\n>;\n\nexport interface MiddlewareContext {\n\tdispatch: Dispatcher;\n\tnext(request: IncomingRequest, env: any): Awaitable<Response>;\n}\n\nexport type Middleware = (\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tmiddlewareCtx: MiddlewareContext\n) => Awaitable<Response>;\n\nconst __facade_middleware__: Middleware[] = [];\n\n// The register functions allow for the insertion of one or many middleware,\n// We register internal middleware first in the stack, but have no way of controlling\n// the order that addMiddleware is run in service workers so need an internal function.\nexport function __facade_register__(...args: (Middleware | Middleware[])[]) {\n\t__facade_middleware__.push(...args.flat());\n}\nexport function __facade_registerInternal__(\n\t...args: (Middleware | Middleware[])[]\n) {\n\t__facade_middleware__.unshift(...args.flat());\n}\n\nfunction __facade_invokeChain__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tmiddlewareChain: Middleware[]\n): Awaitable<Response> {\n\tconst [head, ...tail] = middlewareChain;\n\tconst middlewareCtx: MiddlewareContext = {\n\t\tdispatch,\n\t\tnext(newRequest, newEnv) {\n\t\t\treturn __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);\n\t\t},\n\t};\n\treturn head(request, env, ctx, middlewareCtx);\n}\n\nexport function __facade_invoke__(\n\trequest: IncomingRequest,\n\tenv: any,\n\tctx: ExecutionContext,\n\tdispatch: Dispatcher,\n\tfinalMiddleware: Middleware\n): Awaitable<Response> {\n\treturn __facade_invokeChain__(request, env, ctx, dispatch, [\n\t\t...__facade_middleware__,\n\t\tfinalMiddleware,\n\t]);\n}\n", "// This loads all middlewares exposed on the middleware object and then starts\n// the invocation chain. The big idea is that we can add these to the middleware\n// export dynamically through wrangler, or we can potentially let users directly\n// add them as a sort of \"plugin\" system.\n\nimport ENTRY, { __INTERNAL_WRANGLER_MIDDLEWARE__ } from \"/Users/jackie/statpedia-08/cloudflare-worker/.wrangler/tmp/bundle-QktIh6/middleware-insertion-facade.js\";\nimport { __facade_invoke__, __facade_register__, Dispatcher } from \"/Users/jackie/statpedia-08/cloudflare-worker/node_modules/wrangler/templates/middleware/common.ts\";\nimport type { WorkerEntrypointConstructor } from \"/Users/jackie/statpedia-08/cloudflare-worker/.wrangler/tmp/bundle-QktIh6/middleware-insertion-facade.js\";\n\n// Preserve all the exports from the worker\nexport * from \"/Users/jackie/statpedia-08/cloudflare-worker/.wrangler/tmp/bundle-QktIh6/middleware-insertion-facade.js\";\n\nclass __Facade_ScheduledController__ implements ScheduledController {\n\treadonly #noRetry: ScheduledController[\"noRetry\"];\n\n\tconstructor(\n\t\treadonly scheduledTime: number,\n\t\treadonly cron: string,\n\t\tnoRetry: ScheduledController[\"noRetry\"]\n\t) {\n\t\tthis.#noRetry = noRetry;\n\t}\n\n\tnoRetry() {\n\t\tif (!(this instanceof __Facade_ScheduledController__)) {\n\t\t\tthrow new TypeError(\"Illegal invocation\");\n\t\t}\n\t\t// Need to call native method immediately in case uncaught error thrown\n\t\tthis.#noRetry();\n\t}\n}\n\nfunction wrapExportedHandler(worker: ExportedHandler): ExportedHandler {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn worker;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\tconst fetchDispatcher: ExportedHandlerFetchHandler = function (\n\t\trequest,\n\t\tenv,\n\t\tctx\n\t) {\n\t\tif (worker.fetch === undefined) {\n\t\t\tthrow new Error(\"Handler does not export a fetch() function.\");\n\t\t}\n\t\treturn worker.fetch(request, env, ctx);\n\t};\n\n\treturn {\n\t\t...worker,\n\t\tfetch(request, env, ctx) {\n\t\t\tconst dispatcher: Dispatcher = function (type, init) {\n\t\t\t\tif (type === \"scheduled\" && worker.scheduled !== undefined) {\n\t\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\t\tDate.now(),\n\t\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t\t() => {}\n\t\t\t\t\t);\n\t\t\t\t\treturn worker.scheduled(controller, env, ctx);\n\t\t\t\t}\n\t\t\t};\n\t\t\treturn __facade_invoke__(request, env, ctx, dispatcher, fetchDispatcher);\n\t\t},\n\t};\n}\n\nfunction wrapWorkerEntrypoint(\n\tklass: WorkerEntrypointConstructor\n): WorkerEntrypointConstructor {\n\t// If we don't have any middleware defined, just return the handler as is\n\tif (\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__ === undefined ||\n\t\t__INTERNAL_WRANGLER_MIDDLEWARE__.length === 0\n\t) {\n\t\treturn klass;\n\t}\n\t// Otherwise, register all middleware once\n\tfor (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {\n\t\t__facade_register__(middleware);\n\t}\n\n\t// `extend`ing `klass` here so other RPC methods remain callable\n\treturn class extends klass {\n\t\t#fetchDispatcher: ExportedHandlerFetchHandler<Record<string, unknown>> = (\n\t\t\trequest,\n\t\t\tenv,\n\t\t\tctx\n\t\t) => {\n\t\t\tthis.env = env;\n\t\t\tthis.ctx = ctx;\n\t\t\tif (super.fetch === undefined) {\n\t\t\t\tthrow new Error(\"Entrypoint class does not define a fetch() function.\");\n\t\t\t}\n\t\t\treturn super.fetch(request);\n\t\t};\n\n\t\t#dispatcher: Dispatcher = (type, init) => {\n\t\t\tif (type === \"scheduled\" && super.scheduled !== undefined) {\n\t\t\t\tconst controller = new __Facade_ScheduledController__(\n\t\t\t\t\tDate.now(),\n\t\t\t\t\tinit.cron ?? \"\",\n\t\t\t\t\t() => {}\n\t\t\t\t);\n\t\t\t\treturn super.scheduled(controller);\n\t\t\t}\n\t\t};\n\n\t\tfetch(request: Request<unknown, IncomingRequestCfProperties>) {\n\t\t\treturn __facade_invoke__(\n\t\t\t\trequest,\n\t\t\t\tthis.env,\n\t\t\t\tthis.ctx,\n\t\t\t\tthis.#dispatcher,\n\t\t\t\tthis.#fetchDispatcher\n\t\t\t);\n\t\t}\n\t};\n}\n\nlet WRAPPED_ENTRY: ExportedHandler | WorkerEntrypointConstructor | undefined;\nif (typeof ENTRY === \"object\") {\n\tWRAPPED_ENTRY = wrapExportedHandler(ENTRY);\n} else if (typeof ENTRY === \"function\") {\n\tWRAPPED_ENTRY = wrapWorkerEntrypoint(ENTRY);\n}\nexport default WRAPPED_ENTRY;\n"],
  "mappings": "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",
  "names": ["isPlayerProp", "event"]
}
